creep.work包含了creep注册，creep状态执行。role只提供状态的流转

状态机与同时动作

状态机有三个阶段：enter update exit  
enter 进入该状态时调用  
update 执行状态调用  
exit 转换到其他状态时调用  
同一tick可以(按顺序)执行多个状态，只要这些状态的指令之间没有冲突。

举个升级工升级的例子：  
升级工在link边上，不停升级控制器  
现在: 15W的升级工，手头还剩下15能量，且处于升级状态  
同一tick状态流转如下 ： 
* 升级状态：upgrade() -> 返回下一状态是空
* role.upgrader : 资源不足，下一个状态应该是取能量
* 状态转换: 升级状态 -> 取一次资源状态
* 取一次资源状态: withdraw() -> 返回下一状态是空
* role.upgrader : 填充完毕，下一个状态应该是升级
* 状态转换: 取一次资源状态 -> 升级状态
* 升级状态: enter时发现 要执行的upgrade操作，已经有冲突的指令了，不允许重写，所以活要下tick干。流转结束。


每个tick,policy会对每个房间输出一组group配置信息，分为两类，一种是匿名group配置，只指定group的数量，这种通常是常驻的组：{harvest:2,center:1,build:1,distribute:1},这些组，只关心有没有，数量够不够，不关心其具体配置。另一种是指定配置的group，指定特定group+标识，这种通常是特殊情况产生的组：{remote:[ROOM1,ROOM2,ROOM3],deposit:[pos1,pos2,pos3]},用固定的名字来区分。

根据Policy输出的group配置信息，对比已有的group,处理差异项，新增的部分，根据参数，调用对应group的init方法，减少的部分，标记为disable，不再生creep，creep死完时，删除。